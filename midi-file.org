#+TITLE: Standard MIDI File Format (SMF)


* Introduction
   :PROPERTIES:
   :CUSTOM_ID: introduction
   :END:

This document details the structure of MIDI Files. The purpose of MIDI
Files is to provide a way of interchanging time-stamped MIDI data
between different programs on the same or different computers. One of
the primary design goals is compact representation, which makes it very
appropriate for disk-based file format, but which might make it
inappropriate for storing in memory for quick access by a sequencer
program.

MIDI Files contain one or more MIDI streams, with time information for
each event. Song, sequence, and track structures, tempo and time
signature information, are all supported. Track names and other
descriptive information may be stored with the MIDI data. This format
supports multiple tracks and multiple sequences so that if the user of a
program which supports multiple tracks intends to move a file to another
one, this format can allow that to happen.

The specification defines the 8-bit binary data stream used in the file.
The data can be stored in a binary file, nibbilized, 7-bit-ized for
efficient MIDI transmission, converted to Hex ASCII, or translated
symbolically to a printable text file. This spec addresses what's in the
 8-bit stream. It does not address how a MIDI File will be transmitted
over MIDI.


** Acknowledgement:
    :PROPERTIES:
    :CUSTOM_ID: acknowledgement
    :END:
© Copyright 2019 [[mailto:me@drewc.ca][Drew Crampsie <me@drewc.ca>]]

I went ahead and orgified it, gerbilized it, and changed a bunch. The original
Acknowledgement lies below.

#+BEGIN_QUOTE
This document was originally distributed in text format by The International
MIDI Association. I have updated it and added new Appendices.

© Copyright 1999 David Back.
 
EMail: [[mailto:david@csw2.co.uk][david@csw2.co.uk]] Web: [[http://www.csw2.co.uk/][http://www.csw2.co.uk]]

This document may be freely copied in whole or in part provided the copy
contains this Acknowledgement.
#+END_QUOTE


* Usage


#+BEGIN_SRC gerbil  
  (def (test-midi-file)
    (call-with-input-file "~/src/gerbil-midi/test/By Joe Cocker - With A Little Help From My Friends.kar"
      (lambda (p)
        (let* ((header (read-header-chunk p))
              (tracks (read-chunks p)))
          (printf "Midi File Format ~A. Number of Tracks ~A. Division 0x~x~%"
                  (header-chunk-format header)
                  (header-chunk-number-of-tracks header)
                  (header-chunk-division header))

          tracks))))


  (list (read-chunk-type p)
                (read-chunk-length p)
                (read-events p))









#+END_SRC

* Sequences, Tracks, Chunks: File Block Structure
  :PROPERTIES:
  :CUSTOM_ID: sequences-tracks-chunks-file-block-structure
  :END:

In this document, bit 0 means the least significant bit of a byte, and
bit 7 is the most significant. 

** Variable Length Quantity
   :PROPERTIES:
   :CUSTOM_ID: variable-length-quantity
   :END:

Some numbers in MIDI Files are represented in a form called
VARIABLE-LENGTH QUANTITY. These numbers are represented 7 bits per byte,
most significant bits first. All bytes except the last have bit 7 set,
and the last byte has bit 7 clear. If the number is between 0 and 127,
it is thus represented exactly as one byte.

*Some examples of numbers represented as variable-length quantities:*

| 00000000   | 00            |
| 00000040   | 40            |
| 0000007F   | 7F            |
| 00000080   | 81 00         |
| 00002000   | C0 00         |
| 00003FFF   | FF 7F         |
| 00004000   | 81 80 00      |
| 00100000   | C0 80 00      |
| 001FFFFF   | FF FF 7F      |
| 00200000   | 81 80 80 00   |
| 08000000   | C0 80 80 00   |
| 0FFFFFFF   | FF FF FF 7F   |

The largest number which is allowed is 0FFFFFFF so that the
variable-length representations must fit in 32 bits in a routine to
write variable-length numbers. Theoretically, larger numbers are
possible, but 2 x 10^{8} 96ths of a beat at a fast tempo of 500 beats
per minute is four days, long enough for any delta-time!

#+NAME: variable-length
#+BEGIN_SRC gerbil
(def (read-variable-length-quantity p)
    (let loop ((result 0))
      (let (byte (read-u8 p))
        (if (eof-object? byte)
          result
          (let (result (bitwise-ior
            (arithmetic-shift result 7)
                        (##fxand byte #x7f)))
            (if (##fx< byte #x80)
              result
              (loop result)))))))

#+END_SRC

** Files
   :PROPERTIES:
   :CUSTOM_ID: files
   :END:

To any file system, a MIDI File is simply a series of 8-bit bytes. On
the Macintosh, this byte stream is stored in the data fork of a file
(with file type 'MIDI'), or on the Clipboard (with data type 'MIDI').
Most other computers store 8-bit byte streams in files.

**  Chunks
   :PROPERTIES:
   :CUSTOM_ID: chunks
   :END:

MIDI Files are made up of -chunks-. Each chunk has a 4-character type
and a 32-bit length, which is the number of bytes in the chunk. This
structure allows future chunk types to be designed which may be easily
be ignored if encountered by a program written before the chunk type is
introduced. Your programs should EXPECT alien chunks and treat them as
if they weren't here.

#+NAME: alien-chunk
#+BEGIN_SRC gerbil
  (defstruct (alien-chunk chunk)
    (bytes))
#+END_SRC

Each chunk begins with a 4-character ASCII type. It is followed by a
32-bit length, most significant byte first (a length of 6 is stored as
00 00 00 06). This length refers to the number of bytes of data which
follow: the eight bytes of type and length are not included. Therefore,
a chunk with a length of 6 would actually occupy 14 bytes in the disk
file.

#+NAME: big-endian
#+BEGIN_SRC gerbil
  (def (big-endian->integer list)
    (let loop ((list list)
               (result 0)
               (shift (* 8 (- (length list) 1))))
      (if (null? list)
        result
        (loop (cdr list)
              (bitwise-ior result (arithmetic-shift (car list) shift))
              (- shift 8)))))

  (def (read-big-endian-integer bytes port)
    (let loop ((bytes bytes)
               (result '()))
      (if (= bytes 0)
        (big-endian->integer (reverse result))
        (loop (- bytes 1)
              (cons (read-u8 port) result)))))

#+END_SRC

This chunk architecture is similar to that used by Electronic Arts' IFF
format, and the chunks described herein could easily be placed in an IFF
file. The MIDI File itself is not an IFF file: it contains no nested
chunks, and chunks are not constrained to be an even number of bytes
long. Converting it to an IFF file is as easy as padding odd length
chunks, and sticking the whole thing inside a FORM chunk.

#+NAME: chunk-struct
#+BEGIN_SRC gerbil
  (defstruct chunk
    ;; type is four ascii characters
    (type
     ;; a 32-bit representation of a number
     length))

  (def (read-chunk-length port)
   (read-big-endian-integer 4 port))

#+END_SRC

**  Chunk Types
   :PROPERTIES:
   :CUSTOM_ID: chunk-types
   :END:

MIDI Files contain two types of chunks: header chunks and track chunks.
A -header- chunk provides a minimal amount of information pertaining to
the entire MIDI file. A -track- chunk contains a sequential stream of
MIDI data which may contain information for up to 16 MIDI channels. The
concepts of multiple tracks, multiple MIDI outputs, patterns, sequences,
and songs may all be implemented using several track chunks.

A MIDI File always starts with a header chunk, and is followed by one or
more track chunks.

~MThd <length of header data> <header data>~
~MTrk <length of track data> <track data>~
~MTrk <length of track data> <track data>~

#+NAME: chunk-struct
#+BEGIN_SRC gerbil
  (def (read-chunk-type port)
    (let loop ((bytes 4)
               (result '()))
      (if (= bytes 0)
        (list->string (map integer->char (reverse result)))
        (loop (- bytes 1)
              (cons (read-u8 port) result)))))
#+END_SRC

#+BEGIN_SRC gerbil
  (def (test-new-chunk)
      (call-with-input-file "~/src/gerbil-midi/test/MIDI_sample.mid"
        (lambda (p)
          (let* ((type (read-chunk-type p))
                 (length (read-chunk-length p)))
            (test> type => "MThd")
            (test> length => 6)))))

  (test-new-chunk)
#+END_SRC


* Chunk Descriptions
  :PROPERTIES:
  :CUSTOM_ID: chunk-descriptions
  :END:

#+NAME:read-chunk
#+BEGIN_SRC gerbil 
  (def (read-chunk p)
    (let* ((type (read-chunk-type p))
           (length (read-chunk-length p)))
      (if (equal? "MTrk" type)
        (read-track-chunk type length p)
        (let ((bytes (make-u8vector length)))
          (read-u8vector bytes p)
          (make-alien-chunk type length bytes)))))

  (def (read-chunks p)
    (let ((chunk (read-chunk p))
          (next (peek-u8 p)))
      (if (eof-object? next)
        [chunk]
        (cons chunk (read-chunks p)))))
#+END_SRC
  
** Header Chunks
   :PROPERTIES:
   :CUSTOM_ID: header-chunks
   :END:

The header chunk at the beginning of the file specifies some basic
information about the data in the file. Here's the syntax of the
complete chunk:

~<Header Chunk> = <chunk type><length><format><ntrks><division>~
#+NAME: header-chunk
#+BEGIN_SRC gerbil
 (defstruct (header-chunk chunk)
    (format number-of-tracks division)) 
#+END_SRC

As described above, <chunk type> is the four ASCII characters 'MThd';
<length> is a 32-bit representation of the number 6 (high byte first).

The data section contains three 16-bit words, stored most-significant
byte first.

The first word, <format>, specifies the overall organisation of the
file. Only three values of <format> are specified:

0-the file contains a single multi-channel track\\
1-the file contains one or more simultaneous tracks (or MIDI outputs) of
a sequence\\
2-the file contains one or more sequentially independent single-track
patterns

More information about these formats is provided below.

The next word, <ntrks>, is the number of track chunks in the file. It
will always be 1 for a format 0 file.

The third word, <division>, specifies the meaning of the delta-times. It
has two formats, one for metrical time, and one for time-code-based
time:

+--------+------------------------+-----------------+
| bit 15 | bits 14 thru 8         | bits 7 thru 0   |
+--------+------------------------+-----------------+
|      0 | ticks per quarter-note                   |
+--------+------------------------+-----------------+
|      1 | negative SMPTE format  | ticks per frame |
+--------+------------------------+-----------------+

If bit 15 of <division> is zero, the bits 14 thru 0 represent the number
of delta time "ticks" which make up a quarter-note. For instance, if
division is 96, then a time interval of an eighth-note between two
events in the file would be 48.

If bit 15 of <division> is a one, delta times in a file correspond to
subdivisions of a second, in a way consistent with SMPTE and MIDI Time
ode. Bits 14 thru 8 contain one of the four values -24, -25, -29, or
-30, corresponding to the four standard SMPTE and MIDI Time Code formats
(-29 corresponds to 30 drop frame), and represents the number of frames
per second. These negative numbers are stored in two's compliment form.
The second byte (stored positive) is the resolution within a frame:
typical values may be 4 (MIDI Time Code resolution), 8, 10, 80 (bit
resolution), or 100. This stream allows exact specifications of
time-code-based tracks, but also allows millisecond-based tracks by
specifying 25 frames/sec and a resolution of 40 units per frame. If the
events in a file are stored with a bit resolution of thirty-frame time
code, the division word would be E250 hex.


#+NAME: header-chunk
#+BEGIN_SRC gerbil
  (def (read-header-chunk p)
    (let* ((type (read-chunk-type p)) 
           (length (read-chunk-length p))
           (format (read-big-endian-integer 2 p))
           (number-of-tracks (read-big-endian-integer 2 p))
           (division (read-big-endian-integer 2 p)))
      (make-header-chunk type length format number-of-tracks division)))

#+END_SRC

#+BEGIN_SRC gerbil
  (def (test-header-chunk)
    (call-with-input-file "~/src/gerbil-midi/test/MIDI_sample.mid"
      (lambda (p)
        (let ((header (read-header-chunk p)))
          (test> (header-chunk-format header) => 1)
          (test> (header-chunk-number-of-tracks header) => 6)
          (header-chunk-division header)))))

  (test-header-chunk)

#+END_SRC
** MIDI File Formats 0,1 and 2
   :PROPERTIES:
   :CUSTOM_ID: midi-file-formats-01-and-2
   :END:

#+NAME: midi-file-struct
#+BEGIN_SRC gerbil
  (defstruct midi-file 
   (header-chunk track-chunks))
#+END_SRC

A Format 0 file has a header chunk followed by one track chunk. It is
the most interchangeable representation of data. It is very useful for a
simple single-track player in a program which needs to make synthesisers
make sounds, but which is primarily concerned with something else such
as mixers or sound effect boxes. It is very desirable to be able to
produce such a format, even if your program is track-based, in order to
work with these simple programs.


A Format 1 or 2 file has a header chunk followed by one or more track
chunks. programs which support several simultaneous tracks should be
able to save and read data in format 1, a vertically one dimensional
form, that is, as a collection of tracks. Programs which support several
independent patterns should be able to save and read data in format 2, a
horizontally one dimensional form. Providing these minimum capabilities
will ensure maximum interchangeability.

In a MIDI system with a computer and a SMPTE synchroniser which uses
Song Pointer and Timing Clock, tempo maps (which describe the tempo
throughout the track, and may also include time signature information,
so that the bar number may be derived) are generally created on the
computer. To use them with the synchroniser, it is necessary to transfer
them from the computer. To make it easy for the synchroniser to extract
this data from a MIDI File, tempo information should always be stored in
the first MTrk chunk. For a format 0 file, the tempo will be scattered
through the track and the tempo map reader should ignore the intervening
events; for a format 1 file, the tempo map must be stored as the first
track. It is polite to a tempo map reader to offer your user the ability
to make a format 0 file with just the tempo, unless you can use format
1.

All MIDI Files should specify tempo and time signature. If they don't,
the time signature is assumed to be 4/4, and the tempo 120 beats per
minute. In format 0, these meta-events should occur at least at the
beginning of the single multi-channel track. In format 1, these
meta-events should be contained in the first track. In format 2, each of
the temporally independent patterns should contain at least initial time
signature and tempo information.

Format IDs to support other structures may be defined in the future. A
program encountering an unknown format ID may still read other MTrk
chunks it finds from the file, as format 1 or 2, if its user can make
sense of them and arrange them into some other structure if appropriate.
Also, more parameters may be added to the MThd chunk in the future: it
is important to read and honour the length, even if it is longer than 6.

** Track Chunks
   :PROPERTIES:
   :CUSTOM_ID: track-chunks
   :END:

The track chunks (type MTrk) are where actual song data is stored. Each
track chunk is simply a stream of MIDI events (and non-MIDI events),
preceded by delta-time values. The format for Track Chunks (described
below) is exactly the same for all three formats (0, 1, and 2: see
"Header Chunk" above) of MIDI Files.

Here is the syntax of an MTrk chunk (the + means "one or more": at least
one MTrk event must be present):

<Track Chunk> = <chunk type><length><MTrk event>+

#+NAME: track-chunk 
#+BEGIN_SRC gerbil
  (defstruct (track-chunk chunk)
    (events))

  (def (read-track-chunk type length p)
    (let ((events (read-events p)))
      (make-track-chunk type length events)))

#+END_SRC

**  MTrk event 

The syntax of an MTrk event is very simple:

<MTrk event> = <delta-time><event>

#+NAME: track-event
#+BEGIN_SRC gerbil
  (defstruct MTrk
    (delta-time event))

  (defmethod {print MTrk}
    (lambda (self)
      (printf "MTrk Time: ~A, ~A"
              (MTrk-delta-time self)
              (with-output-to-string
                "" (lambda () {print (MTrk-event self)})))))


#+END_SRC

<delta-time> is stored as a variable-length quantity. It represents the
amount of time before the following event. If the first event in a track
occurs at the very beginning of a track, or if two events occur
simultaneously, a delta-time of zero is used. Delta-times are always
present. (Not storing delta-times of 0 requires at least two bytes for
any other value, and most delta-times aren't zero.) Delta-time is in
some fraction of a beat (or a second, for recording a track with SMPTE
times), as specified in the header chunk.

#+NAME: track-event
#+BEGIN_SRC gerbil
  (def (read-delta-time p)
    (read-variable-length-quantity p))
#+END_SRC

** <event>'s 

 There are three main types of event that can occur within a MTrk chunk - MIDI,
 SysEx and Meta. Events are not all the same size - they use as many bytes as are
 necessary to describe each specific event.

#+BEGIN_SRC bnf
 <event> = <MIDI event> | <sysex event> | <meta-event>
#+END_SRC

 The first byte of the event data (often referred to as the event's status byte,
 and identifiable by their having bit 7 set) identifies the event type.

#+NAME: track-event
 #+BEGIN_SRC gerbil
   (def (status-byte? byte)
     (<= #x80 byte))

 #+END_SRC

#+NAME: track-event
#+BEGIN_SRC gerbil
  (defstruct (unknown-track-event track-event)
   (status bytes))

  (def (read-unknown-track-event time status p)
    (def (%read-bytes)
      (let ((next (peek-u8 p)))
        (if (and (not (eof-object? next))
                 (not (status-byte? next)))
          (let ((byte (read-u8 p)))
            (cons byte (%read-bytes)))
          [])))
    (let ((bytes (%read-bytes)))
      (make-unknown-track-event time status (list->u8vector (%read-bytes)))))


  (defmethod {print unknown-track-event}
    (lambda (self)
      (printf "Unknown ~X ~A ~%"
              (unknown-track-event-status self)
              (unknown-track-event-bytes self))))

  (define (between-or-=? x y z)
    (and (<=  x y)
         (<= y z)))

  (def (read-event p (delta-time #f))
    (let ((delta-time (or delta-time (read-delta-time p)))
          (status (peek-u8 p)))
      ;;(printf "event status? ~X ~%" status )
      (cond ((equal? status #xff)
             (read-meta-event delta-time p))
            ((between-or-=? #x00 status #xEF)
             (read-midi-event delta-time p))
            (else 
             (read-unknown-track-event delta-time status p)))))

  (def (read-events p (delta-time #f))
    (let* ((event (read-event p))
           (next-unknown-delta (if (unknown-track-event? event)
                                 (track-event-delta-time event)
                                 #f)))
      (if (end-of-track-meta-event? event)
        [event]
        (cons event (read-events p next-unknown-delta)))))

#+END_SRC

 
**** Midi events (status bytes 0x8n - 0xEn)

  Midi events (status bytes 0x8n - 0xEn) Corresponding to the standard Channel
  MIDI messages, i.e. where 'n' is the MIDI channel (0 - 15). This status byte
  will be followed by 1 or 2 data bytes, as is usual for the particular MIDI
  message. Any valid Channel MIDI message can be included in a MIDI file.

  If the first (status) byte is less than 128 (hex 80), this implies that running
  status is in effect, and that this byte is actually the first data byte (the
  status carrying over from the previous MIDI event). This can only be the case
  if the immediately previous event was also a MIDI event, i.e. SysEx and Meta
  events interrupt (clear) running status.

 #+NAME: current-running-status
  #+BEGIN_SRC gerbil 
    (def current-running-status
      (make-parameter #f))
  #+END_SRC

**** SysEx events (status bytes 0xF0 and 0xF7) 

  There are a couple of ways in which
  system exclusive messages can be encoded - as a single message (using the 0xF0
  status), or split into packets (using the 0xF7 status). The 0xF7 status is also
  used for sending escape sequences.

  
**** Meta events (status byte 0xFF)
  These contain additional information which would not be in the MIDI data
  stream itself. E.g. TimeSig, KeySig, Tempo, TrackName, Text, Marker, Special,
  EOT (End of Track) events being some of the most common.

  Note that the status bytes associated with System Common messages (0xF1 to
  0xF6 inclusive) and System Real Time messages (0xF8 to 0xFE inclusive) are not
  valid within a MIDI file. Generally none of these messages are relevant within
  a MIDI file, though for the rare occasion when you do need to include one, it
  should be embedded within a SysEx escape sequence.

  The main differences between the contents of a MIDI file and a live stream of MIDI data (i.e. flowing along a MIDI cable) are :

  In MIDI files, all events have an associated delta time value. In a MIDI data
  stream, events happen when they are received. System Common messages (0xF1 to
  0xF6 inclusive) and System Real Time messages (0xF8 to 0xFE inclusive) cannot
  normally occur within a MIDI file (though see escape sequences). As mentioned
  above, within a MIDI file the System Reset status byte (0xFF) is used to
  signify a Meta event, hence Meta events are only found in MIDI files. 

*** <MIDI event> 

   <MIDI event> is any MIDI channel message.

| *Hex* | *Binary* | *Data*  | *Description*                                     |      |                                    |   |
|-------+----------+---------+---------------------------------------------------+------+------------------------------------+---|
| 8x    | 1000xxxx | /nn vv/ | Note off (key is released)                        |      |                                    |   |
|       |          |         |                                                   | /nn/ | note number                        |   |
|       |          |         |                                                   | /vv/ | velocity                           |   |
| 9x    | 1001xxxx | /nn vv/ | Note on (key is pressed)                          |      |                                    |   |
|       |          |         |                                                   | /nn/ | note number                        |   |
|       |          |         |                                                   | /vv/ | velocity                           |   |
| Ax    | 1010xxxx | /nn vv/ | Key after-touch                                   |      |                                    |   |
|       |          |         |                                                   | /nn/ | note number                        |   |
|       |          |         |                                                   | /vv/ | velocity                           |   |
| Bx    | 1011xxxx | /cc vv/ | Control Change                                    |      |                                    |   |
|       |          |         |                                                   | /cc/ | controller number                  |   |
|       |          |         |                                                   | /vv/ | new value                          |   |
| Cx    | 1100xxxx | /pp/    | Program (patch) change                            |      |                                    |   |
|       |          |         |                                                   | /pp/ | new program number                 |   |
| Dx    | 1101xxxx | /cc/    | Channel after-touch                               |      |                                    |   |
|       |          |         |                                                   | /cc/ | channel number                     |   |
| Ex    | 1110xxxx | /bb tt/ | Pitch wheel change (2000H is normal or no change) |      |                                    |   |
|       |          |         |                                                   | /bb/ | bottom (least sig) 7 bits of value |   |
|       |          |         |                                                   | /tt/ | top (most sig) 7 bits of value     |   |

#+NAME: midi-event
#+BEGIN_SRC gerbil
  (defstruct (midi-event track-event)
    (status))

  (def (midi-event-channel midi-event)
    (bitwise-and (midi-event-status midi-event) #b00001111))

  (defmethod {print midi-event}
    (lambda (self) 
      (printf "Channel ~A " (midi-event-channel self))))

  (def (read-midi-event delta-time p)
    (let* ((status (peek-u8 p))
           (status
            (begin (when (>= status #x80)
                     (current-running-status (read-u8 p)))
                   (current-running-status))))
      (cond ((between-or-=? #x80 status #x8F)
              (let* ((n (read-u8 p))
                     (v (read-u8 p)))
                (make-note-off delta-time status n v)))
            ((between-or-=? #x90 status #x9F)
              (let* ((n (read-u8 p))
                     (v (read-u8 p)))
                (make-note-on delta-time status n v)))
            ((between-or-=? #xA0 status #xAF)
             (let* ((n (read-u8 p))
                    (v (read-u8 p)))
               (make-key-aftertouch delta-time status n v)))
            ((between-or-=? #xB0 status #xBF)
             (let* ((n (read-u8 p))
                    (v (read-u8 p)))
               (make-control-change delta-time status n v)))
            ((between-or-=? #xC0 status #xCF)
             (let* ((pp (read-u8 p)))
               (make-patch-change delta-time status pp)))
             ((between-or-=? #xD0 status #xDF)
              (let* ((cc (read-u8 p)))
                (make-channel-aftertouch delta-time status cc)))
              ((between-or-=? #xE0 status #xEF)
               (let* ((bb (read-u8 p))
                      (tt (read-u8 p)))
                (make-pitch-wheel-change delta-time status bb tt)))
            (else (error (format "Not a known midi event: #x~X" status))))))

  (defstruct (note-off midi-event)
    (number velocity))

  (defmethod {print note-off}
    (lambda (self)
      (@next-method self)
      (printf "Note OFF ~A velocity ~A~%"
              (note-off-number self)
              (note-off-velocity self))))

  (defstruct (note-on midi-event)
     (number velocity))
  (defmethod {print note-on}
    (lambda (self) (printf "Note ON ~A velocity ~A~%"
                      (note-on-number self)
                      (note-on-velocity self))))
  (defstruct (key-aftertouch midi-event)
    (note velocity))

  (defstruct (control-change midi-event)
    (controller value))

  (defmethod {print control-change}
    (lambda (self) (printf "Control Change: ~A ~A~%"
                      (control-change-controller self)
                      (control-change-value self))))

  (defstruct (patch-change midi-event)
    (number))

  (defmethod {print patch-change}
    (lambda (self) (printf "Patch (Program) Change: ~A ~%"
                      (patch-change-number self))))

  (defstruct (channel-aftertouch midi-event)
    (number))

  (defmethod {print channel-aftertouch}
    (lambda (self) (printf "Channel After Touch ~A ~%"
                      (channel-aftertouch-number self))))

  (defstruct (pitch-wheel-change midi-event)
    (bottom top))

  (defmethod {print pitch-wheel-change}
    (lambda (self) (printf "Channel After Touch bottom ~A top ~A ~%"
                      (pitch-wheel-change-bottom self)
                      (pitch-wheel-change-top self))))



#+END_SRC

 Running status is used: status bytes of MIDI channel messages may be omitted if
 the preceding event is a MIDI channel message with the same status. The first
 event in each MTrk chunk must specify status. Delta-time is not considered an
 event itself: it is an integral part of the syntax for an MTrk event. Notice
 that running status occurs across delta-times.


***  <sysex event>: a MIDI system exclusive message

<sysex event> is used to specify a MIDI system exclusive message, either as one
unit or in packets, or as an "escape" to specify any arbitrary bytes to be
transmitted. [[#BMA1_][See Appendix 1 - MIDI Messages.]] A normal complete system exclusive
message is stored in a MIDI File in this way:

F0 <length> <bytes to be transmitted after F0>

The length is stored as a variable-length quantity. It specifies the
number of bytes which follow it, not including the F0 or the length
itself. For instance, the transmitted message F0 43 12 00 07 F7 would be
stored in a MIDI File as F0 05 43 12 00 07 F7. It is required to include
the F7 at the end so that the reader of the MIDI File knows that it has
read the entire message.

Another form of sysex event is provided which does not imply that an F0
should be transmitted. This may be used as an "escape" to provide for
the transmission of things which would not otherwise be legal, including
system realtime messages, song pointer or select, MIDI Time Code, etc.
This uses the F7 code:

F7 <length> <all bytes to be transmitted>

Unfortunately, some synthesiser manufacturers specify that their system
exclusive messages are to be transmitted as little packets. Each packet
is only part of an entire syntactical system exclusive message, but the
times they are transmitted are important. Examples of this are the bytes
sent in a CZ patch dump, or the FB-01's "system exclusive mode" in which
microtonal data can be transmitted. The F0 and F7 sysex events may be
used together to break up syntactically complete system exclusive
messages into timed packets.

An F0 sysex event is used for the first packet in a series -- it is a
message in which the F0 should be transmitted. An F7 sysex event is used
for the remainder of the packets, which do not begin with F0. (Of
course, the F7 is not considered part of the system exclusive message).

A syntactic system exclusive message must always end with an F7, even if
the real-life device didn't send one, so that you know when you've
reached the end of an entire sysex message without looking ahead to the
next event in the MIDI File. If it's stored in one complete F0 sysex
event, the last byte must be an F7. There also must not be any
transmittable MIDI events in between the packets of a multi-packet
system exclusive message. This principle is illustrated in the paragraph
below.

Here is a MIDI File of a multi-packet system exclusive message: suppose
the bytes F0 43 12 00 were to be sent, followed by a 200-tick delay,
followed by the bytes 43 12 00 43 12 00, followed by a 100-tick delay,
followed by the bytes 43 12 00 F7, this would be in the MIDI File:

| F0 03 43 12 00            |                       |
| 81 48                     | 200-tick delta time   |
| F7 06 43 12 00 43 12 00   |                       |
| 64                        | 100-tick delta time   |
| F7 04 43 12 00 F7         |                       |

When reading a MIDI File, and an F7 sysex event is encountered without a
preceding F0 sysex event to start a multi-packet system exclusive
message sequence, it should be presumed that the F7 event is being used
as an "escape". In this case, it is not necessary that it end with an
F7, unless it is desired that the F7 be transmitted.

*** <meta-event> 

 <meta-event> specifies non-MIDI information useful to this format or to
 sequencers, with this syntax:

#+BEGIN_SRC bnf
FF <type> <length> <bytes>
#+END_SRC

#+NAME: meta-event
#+BEGIN_SRC gerbil
  (defstruct (meta-event track-event)
    (type length))

  (defmethod {print meta-event}
    (lambda (self) (printf "Meta Event: type ~X length ~A type ~A "
                      (meta-event-type self)
                      (meta-event-length self)
                      (type-of self))))

  (defstruct (unknown-meta-event meta-event)
    (bytes))

  (defmethod {print unknown-meta-event}
    (lambda (self) (printf "Unknown Meta Event: ~X ~A ~A~%"
                      (meta-event-type self)
                      (meta-event-length self)
                      (unknown-meta-event-bytes self))))

  (def meta-event-constructors [])

  (def (find-meta-event-constructor delta-time type length bytes)
    ;;(printf "Lookibgf cons type ~A ~A ~%" type length)
    (def make (assoc type meta-event-constructors eqv?))
    (if make
      (cdr make)
      make-unknown-meta-event))

  (def (read-meta-event delta-time port)
    (let* ((type (begin
                   ;; throwaway #xFF
                   (read-u8 port)
                   (read-u8 port)))
           (length (read-variable-length-quantity port))
           (bytes (make-u8vector length)))
      (read-u8vector bytes port)
      ((find-meta-event-constructor delta-time type length bytes)
       delta-time type length bytes)))


#+END_SRC

All meta-events begin with FF, then have an event type byte (which is
always less than 128), and then have the length of the data stored as a
variable-length quantity, and then the data itself. If there is no data,
the length is 0. As with chunks, future meta-events may be designed
which may not be known to existing programs, so programs must properly
ignore meta-events which they do not recognise, and indeed should expect
to see them. Programs must never ignore the length of a meta-event which
they do not recognise, and they shouldn't be surprised if it's bigger
than expected. If so, they must ignore everything past what they know
about. However, they must not add anything of their own to the end of
the meta- event. 


Sysex events and meta events cancel any running status
which was in effect. Running status does not apply to and may not be
used for these messages.

#+BEGIN_SRC gerbil


#+END_SRC

 
**** Meta-Events
     :PROPERTIES:
     :CUSTOM_ID: meta-events
     :END:

  A few meta-events are defined herein. It is not required for every
  program to support every meta-event.

  In the syntax descriptions for each of the meta-events a set of
  conventions is used to describe parameters of the events. The FF which
  begins each event, the type of each event, and the lengths of events
  which do not have a variable amount of data are given directly in
  hexadecimal. A notation such as dd or se, which consists of two
  lower-case letters, mnemonically represents an 8-bit value. Four
  identical lower-case letters such as wwww mnemonically refer to a 16-bit
  value, stored most-significant-byte first. Six identical lower-case
  letters such as tttttt refer to a 24-bit value, stored
  most-significant-byte first. The notation len refers to the length
  portion of the meta-event syntax, that is, a number, stored as a
  variable- length quantity, which specifies how many bytes (possibly
  text) data were just specified by the length.

  In general, meta-events in a track which occur at the same time may
  occur in any order. If a copyright event is used, it should be placed as
  early as possible in the file, so it will be noticed easily. Sequence
  Number and Sequence/Track Name events, if present, must appear at time
  0. An end-of- track event must occur as the last event in the track.

***** Meta-Event Definitions
      :PROPERTIES:
      :CUSTOM_ID: meta-event-definitions
      :END:

****** *FF 00 02 Sequence Number*
  This optional event, which must occur at the beginning of a track,
  before any nonzero delta-times, and before any transmittable MIDI
  events, specifies the number of a sequence. In a format 2 MIDI File, it
  is used to identify each "pattern" so that a "song" sequence using the
  Cue message can refer to the patterns. If the ID numbers are omitted,
  the sequences' locations in order in the file are used as defaults. In a
  format 0 or 1 MIDI File, which only contain one sequence, this number
  should be contained in the first (or only) track. If transfer of several
  multitrack sequences is required, this must be done as a group of format
  1 files, each with a different sequence number.

****** Text Events
   #+NAME: text-meta-event
   #+BEGIN_SRC gerbil
      (defstruct (text-meta-event meta-event)
       (text))

     (def (construct-text-meta-event time type length bytes)
       (make-text-meta-event time type length (bytes->string bytes)))

   #+END_SRC

  
*******  *FF 01 len text Text Event*

    Any amount of text describing anything. It is a good idea to put a text
    event right at the beginning of a track, with the name of the track, a
    description of its intended orchestration, and any other information
    which the user wants to put there. Text events may also occur at other
    times in a track, to be used as lyrics, or descriptions of cue points.
    The text in this event should be printable ASCII characters for maximum
    interchange. However, other character codes using the high-order bit may
    be used for interchange of files between different programs on the same
    computer which supports an extended character set. Programs on a
    computer which does not support non-ASCII characters should ignore those
    characters.

    Meta-event types 01 through 0F are reserved for various types of text
    events, each of which meets the specification of text events (above) but
    is used for a different purpose:

    #+NAME: text-meta-event
    #+BEGIN_SRC gerbil
      (let lp ((i #x01))
        (set! meta-event-constructors
          (cons (cons i construct-text-meta-event)
                meta-event-constructors))
       (when (< i #x0f)
           (lp (+ 1 i))))
    #+END_SRC

   
******* *FF 02 len text Copyright Notice*\\
    Contains a copyright notice as printable ASCII text. The notice should
    contain the characters (C), the year of the copyright, and the owner of
    the copyright. If several pieces of music are in the same MIDI File, all
    of the copyright notices should be placed together in this event so that
    it will be at the beginning of the file. This event should be the first
    event in the track chunk, at time 0.

    
******* *FF 03 len text Sequence/Track Name*\\
    If in a format 0 track, or the first track in a format 1 file, the name
    of the sequence. Otherwise, the name of the track.

    *FF 04 len text Instrument Name*\\
    A description of the type of instrumentation to be used in that track.
    May be used with the MIDI Prefix meta-event to specify which MIDI
    channel the description applies to, or the channel may be specified as
    text in the event itself.

    *FF 05 len text Lyric*\\
    A lyric to be sung. Generally, each syllable will be a separate lyric
    event which begins at the event's time.

    *FF 06 len text Marker*\\
    Normally in a format 0 track, or the first track in a format 1 file. The
    name of that point in the sequence, such as a rehearsal letter or
    section name ("First Verse", etc.)

    *FF 07 len text Cue Point*\\
    A description of something happening on a film or video screen or stage
    at that point in the musical score ("Car crashes into house", "curtain
    opens", "she slaps his face", etc.)


    #+NAME: text-meta-event
    #+BEGIN_SRC gerbil
        (def text-meta-events
         [[01 . "Text Event"]
          [02 . "Copyright Notice"]
          [03 . "Sequence/Track Name"]
          [04 . "Instrument Name"]
          [05 . "Lyric"]
          [06 . "Marker"]
          [07 . "Cue Point"]])

      (def (text-meta-event-type text-meta-event)
        (let ((string (assoc (meta-event-type text-meta-event) text-meta-events eqv?)))
          (if string (cdr string) "")))

      (defmethod {print text-meta-event}
          (lambda (self)
      ;     (@next-method self)
            (printf "Time: ~A Text ~A: ~A~%"
                    (track-event-delta-time self)
                    (text-meta-event-type self)
                    (text-meta-event-text self))))
 #+END_SRC

****** *FF 20 01 cc MIDI Channel Prefix*
The MIDI channel (0-15) contained in this event may be used to associate
a MIDI channel with all events which follow, including System exclusive
and meta-events. This channel is "effective" until the next normal MIDI
event (which contains a channel) or the next MIDI Channel Prefix
meta-event. If MIDI channels refer to "tracks", this message may be put
into a format 0 file, keeping their non-MIDI data associated with a
track. This capability is also present in Yamaha's ESEQ file format.

****** *FF 2F 00 End of Track*
This event is not optional. It is included so that an exact ending point
may be specified for the track, so that an exact length is defined,
which is necessary for tracks which are looped or concatenated.

#+NAME: end-of-track-meta-event
#+BEGIN_SRC gerbil
  (defstruct (end-of-track-meta-event meta-event) ())

  (def (construct-end-of-track-meta-event time type length bytes)
    (printf "End of track. Time: ~A type ~X length ~A bytes ~A"
            time type length bytes)
     (make-end-of-track-meta-event time type length))

  (set! meta-event-constructors
      (cons (cons #x2F construct-end-of-track-meta-event) meta-event-constructors))

  (defmethod {print end-of-track-meta-event}
      (lambda (self)
        (printf "End of Track~%")))
#+END_SRC

****** *FF 51 03 tttttt Set Tempo (in microseconds per MIDI quarter-note)*
This event indicates a tempo change. Another way of putting
"microseconds per quarter-note" is "24ths of a microsecond per MIDI
clock". Representing tempos as time per beat instead of beat per time
allows absolutely exact long-term synchronisation with a time-based sync
protocol such as SMPTE time code or MIDI time code. The amount of
accuracy provided by this tempo resolution allows a four-minute piece at
120 beats per minute to be accurate within 500 usec at the end of the
piece. Ideally, these events should only occur where MIDI clocks would
be located -- this convention is intended to guarantee, or at least
increase the likelihood, of compatibility with other synchronisation
devices so that a time signature/tempo map stored in this format may
easily be transferred to another device.
(
#+NAME: set-tempo-meta-event
#+BEGIN_SRC gerbil
  (defstruct (set-tempo-meta-event meta-event)
    (time))

  (def (construct-set-tempo-meta-event time type length bytes)
    (make-set-tempo-meta-event time type length (big-endian->integer
                                                 (u8vector->list bytes))))

  (set! meta-event-constructors
    (cons (cons #x51 construct-set-tempo-meta-event) meta-event-constructors))

  (defmethod {print set-tempo-meta-event}
    (lambda (self)
      (printf "Set Tempo: ~1,1Fbpm ~Amu (microseconds) per quarter-note ~%" 
              (/ 60000000 (set-tempo-meta-event-time self))
              (set-tempo-meta-event-time self))))

#+END_SRC


****** *FF 54 05 hr mn se fr ff SMPTE Offset*
This event, if present, designates the SMPTE time at which the track
chunk is supposed to start. It should be present at the beginning of the
track, that is, before any nonzero delta-times, and before any
transmittable MIDI events. the hour must be encoded with the SMPTE
format, just as it is in MIDI Time Code. In a format 1 file, the SMPTE
Offset must be stored with the tempo map, and has no meaning in any of
the other tracks. The ff field contains fractional frames, in 100ths of
a frame, even in SMPTE-based tracks which specify a different frame
subdivision for delta-times.


****** *FF 58 04 nn dd cc bb Time Signature*
The time signature is expressed as four numbers. nn and dd represent the
numerator and denominator of the time signature as it would be notated.
The denominator is a negative power of two: 2 represents a quarter-note,
3 represents an  ighth-note, etc. The cc parameter expresses the number
of MIDI clocks in a metronome click. The bb parameter expresses the
number of notated 32nd-notes in a MIDI quarter-note (24 MIDI clocks).
This was added because there are already multiple programs which allow a
user to specify that what MIDI thinks of as a quarter-note (24 clocks)
is to be notated as, or related to in terms of, something else.

#+NAME: time-signature-meta-event
#+BEGIN_SRC gerbil
  (defstruct (time-signature-meta-event meta-event)
    (numerator denominator clocks-click 32nd-per-click))

  (def (construct-time-signature-meta-event time type length bytes)
    (make-time-signature-meta-event time type length 
     (u8vector-ref bytes 0)(u8vector-ref bytes 1)(u8vector-ref bytes 2)(u8vector-ref bytes 3)))

  (set! meta-event-constructors 
    (cons (cons #x58 construct-time-signature-meta-event) meta-event-constructors))

#+END_SRC

Therefore, the complete event for 6/8 time, where the metronome clicks
every three eighth-notes, but there are 24 clocks per quarter-note, 72
to the bar, would be (in hex):

FF 58 04 06 03 24 08

That is, 6/8 time (8 is 2 to the 3rd power, so this is 06 03), 36 MIDI
clocks per dotted-quarter (24 hex!), and eight notated 32nd-notes per
quarter-note.


#+NAME: time-signature-meta-event
#+BEGIN_SRC gerbil
  (defmethod {print time-signature-meta-event}
    (lambda (self) 
      (printf "Time Signature: ~A/~A ~A MIDI clocks per dotted-quarter, ~A notated 32nd-notes per quarter-note.~%"

          (time-signature-meta-event-numerator self)
          (denominator (expt 2 (* (time-signature-meta-event-denominator self) -1)))
          (time-signature-meta-event-clocks-click self)
          (time-signature-meta-event-32nd-per-click self))))
#+END_SRC

****** *FF 59 02 sf mi Key Signature*\\
sf = -7: 7 flats\\
sf = -1: 1 flat\\
sf = 0: key of C\\
sf = 1: 1 sharp\\
sf = 7: 7 sharps\\

mi = 0: major key\\
mi = 1: minor key\\

****** *FF 7F len data Sequencer Specific Meta-Event*\\
Special requirements for particular sequencers may use this event type:
the first byte or bytes of data is a manufacturer ID (these are one
byte, or if the first byte is 00, three bytes). As with MIDI System
Exclusive, manufacturers who define something using this meta-event
should publish it so that others may be used by a sequencer which elects
to use this as its only file format; sequencers with their established
feature-specific formats should probably stick to the standard features
when using this format.

* Gerbil Files

** midi-file.ss

#+BEGIN_SRC gerbil :tangle midi-file.ss :noweb yes

  (import
    :gerbil/gambit
    :gerbil/gambit/ports
    :scheme/base
    :std/iter
    :std/format
    :std/generic)

  (export #t)
  <<midi-file-struct>>

  <<variable-length>>

  <<big-endian>>

  <<chunk-struct>>

  <<read-chunk>>
  
  <<alien-chunk>>

  <<header-chunk>>

  <<track-chunk>>

  <<track-event>>

  <<current-running-status>>

  <<midi-event>>

  <<meta-event>>

  <<text-meta-event>>

  <<end-of-track-meta-event>>

  <<set-tempo-meta-event>> 

  <<time-signature-meta-event>>
#+END_SRC

** midi-file-test.ss

#+BEGIN_SRC gerbil :tangle midi-file-test.ss
  (import :drewc/midi-file)

  (defrules test> ()
    ((_ form => value)
     (let ((v value)
           (f form))
       (if (equal? f v)
         v
         (error "Test failed:" 'form 'is f 'not v)))))
#+END_SRC
